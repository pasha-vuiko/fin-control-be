diff --git a/node_modules/drizzle-prisma-generator/README.md b/node_modules/drizzle-prisma-generator/README.md
index e53378c..42fc912 100644
--- a/node_modules/drizzle-prisma-generator/README.md
+++ b/node_modules/drizzle-prisma-generator/README.md
@@ -10,11 +10,13 @@ Automatically generate Drizzle schema from Prisma schema
 generator drizzle {
   provider = "drizzle-prisma-generator"
   output = "./src/schema.ts"
+  relationsVersion = "v1"
 }
 ```
 :warning: - if output doesn't end with `.ts`, it will be treated like a folder, and schema will be generated to `schema.ts` inside of it.  
 :warning: - binary types in `MySQL`, `PostgreSQL` are not yet supported by `drizzle-orm`, therefore will throw an error.  
 :warning: - generator only supports `postgresql`, `mysql`, `sqlite` data providers, others will throw an error.
+:warning: - currently the supported value for `relationsVersion` is v1. if `relationsVersion` is not provided, the relations file for rqbv2 is generated and saved inside the parent folder of `schema.ts` as `relations.ts`
 
 -  Install `drizzle-orm`: `pnpm add drizzle-orm`  
 -  Import schema from specified output file\folder  
diff --git a/node_modules/drizzle-prisma-generator/index.js b/node_modules/drizzle-prisma-generator/index.js
index d8ecc2a..345e995 100644
--- a/node_modules/drizzle-prisma-generator/index.js
+++ b/node_modules/drizzle-prisma-generator/index.js
@@ -29,12 +29,12 @@ var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__ge
 var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
 
 // src/index.ts
-var src_exports = {};
-__export(src_exports, {
-  default: () => src_default,
+var index_exports = {};
+__export(index_exports, {
+  default: () => index_default,
   generator: () => generator
 });
-module.exports = __toCommonJS(src_exports);
+module.exports = __toCommonJS(index_exports);
 
 // src/globals/index.ts
 var generatorName = "Drizzle Prisma generator";
@@ -42,7 +42,7 @@ var defaultPath = "./src/drizzle/";
 
 // src/index.ts
 var import_generator_helper4 = require("@prisma/generator-helper");
-var import_path2 = __toESM(require("path"));
+var import_path5 = __toESM(require("path"));
 
 // package.json
 var version = "0.1.7";
@@ -156,8 +156,7 @@ var getJoinIdType = (typeName, models) => {
     throw new Error("Could not find referenced model of many-to-many relation");
   }
   const idField = joinedModel.fields.find((f) => f.isId);
-  if (!idField)
-    throw new Error("No ID field on referenced model of many-to-many relation");
+  if (!idField) throw new Error("No ID field on referenced model of many-to-many relation");
   return idField.type;
 };
 var getJoinIdName = (typeName, models) => {
@@ -166,8 +165,7 @@ var getJoinIdName = (typeName, models) => {
     throw new Error("Could not find referenced model of many-to-many relation");
   }
   const idField = joinedModel.fields.find((f) => f.isId);
-  if (!idField)
-    throw new Error("No ID field on referenced model of many-to-many relation");
+  if (!idField) throw new Error("No ID field on referenced model of many-to-many relation");
   return idField.name;
 };
 var filterManyToManyRelationFields = (models) => {
@@ -181,16 +179,16 @@ var filterManyToManyRelationFields = (models) => {
 };
 var extractManyToManyModels = (models) => {
   const manyToManyFields = filterManyToManyRelationFields(models);
-  if (!manyToManyFields.length)
-    return [];
+  if (!manyToManyFields.length) return [];
   return generateModels(manyToManyFields, models, []);
 };
 
 // src/util/generators/mysql.ts
 var import_generator_helper = require("@prisma/generator-helper");
+var import_path = __toESM(require("path"));
 var mySqlImports = /* @__PURE__ */ new Set(["mysqlTable"]);
 var drizzleImports = /* @__PURE__ */ new Set([]);
-var prismaToDrizzleType = (type, colDbName, prismaEnum) => {
+var prismaToDrizzleType = (type, colDbName, prismaEnum, nativeType, nativeTypeAttributes) => {
   if (prismaEnum) {
     mySqlImports.add("mysqlEnum");
     return `mysqlEnum('${colDbName}', [${prismaEnum.values.map((val) => `'${val.dbName ?? val.name}'`).join(", ")}])`;
@@ -205,6 +203,11 @@ var prismaToDrizzleType = (type, colDbName, prismaEnum) => {
     case "bytes":
       throw new import_generator_helper.GeneratorError("Drizzle ORM doesn't support binary data type for MySQL");
     case "datetime":
+      if (nativeType === "Time") {
+        mySqlImports.add("time");
+        const precision = nativeTypeAttributes?.at(0) ?? "3";
+        return `time('${colDbName}', { precision: ${precision} })`;
+      }
       mySqlImports.add("datetime");
       return `datetime('${colDbName}', { fsp: 3 })`;
     case "decimal":
@@ -227,12 +230,9 @@ var prismaToDrizzleType = (type, colDbName, prismaEnum) => {
   }
 };
 var addColumnModifiers = (field, column) => {
-  if (field.isRequired)
-    column = column + `.notNull()`;
-  if (field.isId)
-    column = column + `.primaryKey()`;
-  if (field.isUnique)
-    column = column + `.unique()`;
+  if (field.isRequired) column = column + `.notNull()`;
+  if (field.isId) column = column + `.primaryKey()`;
+  if (field.isUnique) column = column + `.unique()`;
   if (field.default) {
     const defVal = field.default;
     switch (typeof defVal) {
@@ -261,7 +261,7 @@ var addColumnModifiers = (field, column) => {
           drizzleImports.add("sql");
           break;
         }
-        if (/^uuid\([0-9]*\)$/.test(value.name)) {
+        if (/^uuid\([0-9]*\)$/.test(value.name) || value.name === "uuid") {
           column = column + `.default(sql\`uuid()\`)`;
           drizzleImports.add("sql");
           break;
@@ -275,16 +275,17 @@ var addColumnModifiers = (field, column) => {
   }
   return column;
 };
-var prismaToDrizzleColumn = (field, enums) => {
+var prismaToDrizzleColumn = (field, enums, nativeType, nativeTypeAttributes) => {
   const colDbName = s(field.dbName ?? field.name);
   let column = `	${field.name}: `;
   const drizzleType = prismaToDrizzleType(
     field.type,
     colDbName,
-    field.kind === "enum" ? enums.find((e) => e.name === field.type) : void 0
+    field.kind === "enum" ? enums.find((e) => e.name === field.type) : void 0,
+    nativeType,
+    nativeTypeAttributes
   );
-  if (!drizzleType)
-    return void 0;
+  if (!drizzleType) return void 0;
   column = column + drizzleType;
   column = addColumnModifiers(field, column);
   return column;
@@ -296,16 +297,27 @@ var generateMySqlSchema = (options) => {
   const modelsWithImplicit = [...clonedModels, ...manyToManyModels];
   const tables = [];
   const rqb = [];
+  const rqbv2 = [];
   for (const schemaTable of modelsWithImplicit) {
     const tableDbName = s(schemaTable.dbName ?? schemaTable.name);
     const columnFields = Object.fromEntries(
-      schemaTable.fields.map((e) => [e.name, prismaToDrizzleColumn(e, enums)]).filter((e) => e[1] !== void 0)
+      schemaTable.fields.map((field) => {
+        const [nativeType, nativeTypeAttributes = []] = field.nativeType ?? [];
+        return [
+          field.name,
+          prismaToDrizzleColumn(
+            field,
+            enums,
+            nativeType,
+            nativeTypeAttributes
+          )
+        ];
+      }).filter((field) => field.at(1) !== void 0)
     );
     const indexes = [];
     const relFields = schemaTable.fields.filter((field) => field.relationToFields && field.relationFromFields);
-    const relations = relFields.map((field) => {
-      if (!field?.relationFromFields?.length)
-        return void 0;
+    const relations2 = relFields.map((field) => {
+      if (!field?.relationFromFields?.length) return void 0;
       const fkeyName = s(`${schemaTable.dbName ?? schemaTable.name}_${field.dbName ?? field.name}_fkey`);
       let deleteAction;
       switch (field.relationOnDelete) {
@@ -337,7 +349,7 @@ var generateMySqlSchema = (options) => {
 		.onDelete('${deleteAction}')` : ""}
 		.onUpdate('cascade')`;
     }).filter((e) => e !== void 0);
-    indexes.push(...relations);
+    indexes.push(...relations2);
     if (schemaTable.uniqueIndexes.length) {
       mySqlImports.add("uniqueIndex");
       const uniques = schemaTable.uniqueIndexes.map((idx) => {
@@ -363,9 +375,8 @@ ${Object.values(columnFields).join(",\n")}
 ${indexes.join(",\n")}
 })` : ""});`;
     tables.push(table);
-    if (!relFields.length)
-      continue;
-    drizzleImports.add("relations");
+    if (!relFields.length) continue;
+    if (options.generator.config["relationsVersion"] == "v1") drizzleImports.add("relations");
     const relationArgs = /* @__PURE__ */ new Set();
     const rqbFields = relFields.map((field) => {
       relationArgs.add(field.relationFromFields?.length ? "one" : "many");
@@ -382,6 +393,20 @@ ${indexes.join(",\n")}
     const rqbRelation = `export const ${schemaTable.name}Relations = relations(${schemaTable.name}, ({ ${argString} }) => ({
 ${rqbFields}
 }));`;
+    const rqbv2Fields = relFields.map((field) => {
+      const relName = s(field.relationName ?? "");
+      return `		${field.name}: ${field.relationFromFields?.length ? `r.one.${field.type}({
+			from: r.${schemaTable.name}.${field.relationFromFields.at(0)},
+			to: r.${field.type}.${field.relationToFields?.at(0)},
+			alias: '${relName}'
+		})` : `r.many.${field.type}({
+			alias: '${relName}'
+		})`}`;
+    }).join(",\n");
+    const rqbv2Relation = `	${schemaTable.name}: {
+${rqbv2Fields}
+	}`;
+    rqbv2.push(rqbv2Relation);
     rqb.push(rqbRelation);
   }
   const drizzleImportsArr = Array.from(drizzleImports.values()).sort((a, b) => a.localeCompare(b));
@@ -389,18 +414,28 @@ ${rqbFields}
   const mySqlImportsArr = Array.from(mySqlImports.values()).sort((a, b) => a.localeCompare(b));
   const mySqlImportsStr = mySqlImportsArr.length ? `import { ${mySqlImportsArr.join(", ")} } from 'drizzle-orm/mysql-core'` : void 0;
   let importsStr = [drizzleImportsStr, mySqlImportsStr].filter((e) => e !== void 0).join("\n");
-  if (!importsStr.length)
-    importsStr = void 0;
-  const output = [importsStr, ...tables, ...rqb].filter((e) => e !== void 0).join("\n\n");
-  return output;
+  if (!importsStr.length) importsStr = void 0;
+  const schemaFileName = options.schemaPath ? import_path.default.basename(options.schemaPath, import_path.default.extname(options.schemaPath)) : "schema";
+  let rqbv2Imports = [
+    `import { defineRelations } from "drizzle-orm";`,
+    `import * as schema from "./${schemaFileName}";`
+  ];
+  const rqbv2Relations = `
+export const relations = defineRelations(schema, (r) => ({
+${rqbv2.join(",\n")}
+}));`;
+  const relations = [...rqbv2Imports, rqbv2Relations].join("\n");
+  const schema = [importsStr, ...tables, ...options.generator.config["relationsVersion"] == "v1" ? rqb : []].filter((e) => e !== void 0).join("\n\n");
+  return [schema, relations];
 };
 
 // src/util/generators/pg.ts
 var import_generator_helper2 = require("@prisma/generator-helper");
+var import_path2 = __toESM(require("path"));
 var pgImports = /* @__PURE__ */ new Set();
 var drizzleImports2 = /* @__PURE__ */ new Set();
 pgImports.add("pgTable");
-var prismaToDrizzleType2 = (type, colDbName, defVal) => {
+var prismaToDrizzleType2 = (type, colDbName, defVal, nativeType, nativeTypeAttributes) => {
   switch (type.toLowerCase()) {
     case "bigint":
       pgImports.add("bigint");
@@ -411,15 +446,48 @@ var prismaToDrizzleType2 = (type, colDbName, defVal) => {
     case "bytes":
       throw new import_generator_helper2.GeneratorError("Drizzle ORM doesn't support binary data type for PostgreSQL");
     case "datetime":
+      if (nativeType === "Date") {
+        pgImports.add("date");
+        return `date('${colDbName}')`;
+      }
+      if (nativeType === "Time") {
+        pgImports.add("time");
+        const precision2 = nativeTypeAttributes?.[0] ?? "3";
+        return `time('${colDbName}', { precision: ${precision2} })`;
+      }
+      if (nativeType === "Timetz") {
+        const precision2 = nativeTypeAttributes?.[0] ?? "3";
+        return `time('${colDbName}', { precision: ${precision2}, withTimezone: true })`;
+      }
+      if (nativeType === "Timestamp") {
+        pgImports.add("timestamp");
+        const precision2 = nativeTypeAttributes?.[0] ?? "3";
+        return `timestamp('${colDbName}', { precision: ${precision2} })`;
+      }
+      if (nativeType === "Timestamptz") {
+        pgImports.add("timestamp");
+        const precision2 = nativeTypeAttributes?.[0] ?? "3";
+        return `timestamp('${colDbName}', { precision: ${precision2}, withTimezone: true })`;
+      }
       pgImports.add("timestamp");
       return `timestamp('${colDbName}', { precision: 3 })`;
     case "decimal":
       pgImports.add("decimal");
-      return `decimal('${colDbName}', { precision: 65, scale: 30 })`;
+      const precision = nativeTypeAttributes?.[0] ?? "65";
+      const scale = nativeTypeAttributes?.[1] ?? "30";
+      return `decimal('${colDbName}', { precision: ${precision}, scale: ${scale} })`;
     case "float":
       pgImports.add("doublePrecision");
       return `doublePrecision('${colDbName}')`;
     case "json":
+      if (nativeType === "Json") {
+        pgImports.add("json");
+        return `json('${colDbName}')`;
+      }
+      if (nativeType === "JsonB") {
+        pgImports.add("jsonb");
+        return `jsonb('${colDbName}')`;
+      }
       pgImports.add("jsonb");
       return `jsonb('${colDbName}')`;
     case "int":
@@ -430,6 +498,10 @@ var prismaToDrizzleType2 = (type, colDbName, defVal) => {
       pgImports.add("integer");
       return `integer('${colDbName}')`;
     case "string":
+      if (nativeType === "Uuid") {
+        pgImports.add("uuid");
+        return `uuid('${colDbName}')`;
+      }
       pgImports.add("text");
       return `text('${colDbName}')`;
     default:
@@ -437,14 +509,10 @@ var prismaToDrizzleType2 = (type, colDbName, defVal) => {
   }
 };
 var addColumnModifiers2 = (field, column) => {
-  if (field.isList)
-    column = column + `.array()`;
-  if (field.isRequired)
-    column = column + `.notNull()`;
-  if (field.isId)
-    column = column + `.primaryKey()`;
-  if (field.isUnique)
-    column = column + `.unique()`;
+  if (field.isList) column = column + `.array()`;
+  if (field.isRequired) column = column + `.notNull()`;
+  if (field.isId) column = column + `.primaryKey()`;
+  if (field.isUnique) column = column + `.unique()`;
   if (field.default) {
     const defVal = field.default;
     switch (typeof defVal) {
@@ -472,7 +540,7 @@ var addColumnModifiers2 = (field, column) => {
           drizzleImports2.add("sql");
           break;
         }
-        if (/^uuid\([0-9]*\)$/.test(value.name)) {
+        if (/^uuid\([0-9]*\)$/.test(value.name) || value.name === "uuid") {
           column = column + `.default(sql\`uuid()\`)`;
           drizzleImports2.add("sql");
           break;
@@ -486,16 +554,21 @@ var addColumnModifiers2 = (field, column) => {
   }
   return column;
 };
-var prismaToDrizzleColumn2 = (field) => {
+var prismaToDrizzleColumn2 = (field, nativeType, nativeTypeAttributes) => {
   const colDbName = s(field.dbName ?? field.name);
   let column = `	${field.name}: `;
   if (field.kind === "enum") {
     column = column + `${field.type}('${colDbName}')`;
   } else {
     const defVal = typeof field.default === "object" && !Array.isArray(field.default) ? field.default.name : void 0;
-    const drizzleType = prismaToDrizzleType2(field.type, colDbName, defVal);
-    if (!drizzleType)
-      return void 0;
+    const drizzleType = prismaToDrizzleType2(
+      field.type,
+      colDbName,
+      defVal,
+      nativeType,
+      nativeTypeAttributes
+    );
+    if (!drizzleType) return void 0;
     column = column + drizzleType;
   }
   column = addColumnModifiers2(field, column);
@@ -508,8 +581,7 @@ var generatePgSchema = (options) => {
   const modelsWithImplicit = [...clonedModels, ...manyToManyModels];
   const pgEnums = [];
   for (const schemaEnum of enums) {
-    if (!schemaEnum.values.length)
-      continue;
+    if (!schemaEnum.values.length) continue;
     const enumDbName = s(schemaEnum.dbName ?? schemaEnum.name);
     pgImports.add("pgEnum");
     pgEnums.push(
@@ -518,16 +590,26 @@ var generatePgSchema = (options) => {
   }
   const tables = [];
   const rqb = [];
+  const rqbv2 = [];
   for (const schemaTable of modelsWithImplicit) {
     const tableDbName = s(schemaTable.dbName ?? schemaTable.name);
     const columnFields = Object.fromEntries(
-      schemaTable.fields.map((e) => [e.name, prismaToDrizzleColumn2(e)]).filter((e) => e[1] !== void 0)
+      schemaTable.fields.map((field) => {
+        const [nativeType, nativeTypeAttributes = []] = field.nativeType ?? [];
+        return [
+          field.name,
+          prismaToDrizzleColumn2(
+            field,
+            nativeType,
+            nativeTypeAttributes
+          )
+        ];
+      }).filter((field) => field.at(1) !== void 0)
     );
     const indexes = [];
     const relFields = schemaTable.fields.filter((field) => field.relationToFields && field.relationFromFields);
-    const relations = relFields.map((field) => {
-      if (!field?.relationFromFields?.length)
-        return void 0;
+    const relations2 = relFields.map((field) => {
+      if (!field?.relationFromFields?.length) return void 0;
       const fkeyName = s(`${schemaTable.dbName ?? schemaTable.name}_${field.dbName ?? field.name}_fkey`);
       let deleteAction;
       switch (field.relationOnDelete) {
@@ -559,7 +641,7 @@ var generatePgSchema = (options) => {
 		.onDelete('${deleteAction}')` : ""}
 		.onUpdate('cascade')`;
     }).filter((e) => e !== void 0);
-    indexes.push(...relations);
+    indexes.push(...relations2);
     if (schemaTable.uniqueIndexes.length) {
       pgImports.add("uniqueIndex");
       const uniques = schemaTable.uniqueIndexes.map((idx) => {
@@ -585,9 +667,8 @@ ${Object.values(columnFields).join(",\n")}
 ${indexes.join(",\n")}
 })` : ""});`;
     tables.push(table);
-    if (!relFields.length)
-      continue;
-    drizzleImports2.add("relations");
+    if (!relFields.length) continue;
+    if (options.generator.config["relationsVersion"] == "v1") drizzleImports2.add("relations");
     const relationArgs = /* @__PURE__ */ new Set();
     const rqbFields = relFields.map((field) => {
       relationArgs.add(field.relationFromFields?.length ? "one" : "many");
@@ -604,6 +685,20 @@ ${indexes.join(",\n")}
     const rqbRelation = `export const ${schemaTable.name}Relations = relations(${schemaTable.name}, ({ ${argString} }) => ({
 ${rqbFields}
 }));`;
+    const rqbv2Fields = relFields.map((field) => {
+      const relName = s(field.relationName ?? "");
+      return `		${field.name}: ${field.relationFromFields?.length ? `r.one.${field.type}({
+			from: r.${schemaTable.name}.${field.relationFromFields.at(0)},
+			to: r.${field.type}.${field.relationToFields?.at(0)},
+			alias: '${relName}'
+		})` : `r.many.${field.type}({
+			alias: '${relName}'
+		})`}`;
+    }).join(",\n");
+    const rqbv2Relation = `	${schemaTable.name}: {
+${rqbv2Fields}
+	}`;
+    rqbv2.push(rqbv2Relation);
     rqb.push(rqbRelation);
   }
   const drizzleImportsArr = Array.from(drizzleImports2.values()).sort((a, b) => a.localeCompare(b));
@@ -611,14 +706,29 @@ ${rqbFields}
   const pgImportsArr = Array.from(pgImports.values()).sort((a, b) => a.localeCompare(b));
   const pgImportsStr = pgImportsArr.length ? `import { ${pgImportsArr.join(", ")} } from 'drizzle-orm/pg-core'` : void 0;
   let importsStr = [drizzleImportsStr, pgImportsStr].filter((e) => e !== void 0).join("\n");
-  if (!importsStr.length)
-    importsStr = void 0;
-  const output = [importsStr, ...pgEnums, ...tables, ...rqb].filter((e) => e !== void 0).join("\n\n");
-  return output;
+  if (!importsStr.length) importsStr = void 0;
+  const schemaFileName = options.schemaPath ? import_path2.default.basename(options.schemaPath, import_path2.default.extname(options.schemaPath)) : "schema";
+  let rqbv2Imports = [
+    `import { defineRelations } from "drizzle-orm";`,
+    `import * as schema from "./${schemaFileName}";`
+  ];
+  const rqbv2Relations = `
+export const relations = defineRelations(schema, (r) => ({
+${rqbv2.join(",\n")}
+}));`;
+  const relations = [...rqbv2Imports, rqbv2Relations].join("\n");
+  const schema = [
+    importsStr,
+    ...pgEnums,
+    ...tables,
+    ...options.generator.config["relationsVersion"] == "v1" ? rqb : []
+  ].filter((e) => e !== void 0).join("\n\n");
+  return [schema, relations];
 };
 
 // src/util/generators/sqlite.ts
 var import_generator_helper3 = require("@prisma/generator-helper");
+var import_path3 = __toESM(require("path"));
 var sqliteImports = /* @__PURE__ */ new Set(["sqliteTable"]);
 var drizzleImports3 = /* @__PURE__ */ new Set([]);
 var prismaToDrizzleType3 = (type, colDbName) => {
@@ -655,12 +765,9 @@ var prismaToDrizzleType3 = (type, colDbName) => {
   }
 };
 var addColumnModifiers3 = (field, column) => {
-  if (field.isRequired)
-    column = column + `.notNull()`;
-  if (field.isId)
-    column = column + `.primaryKey()`;
-  if (field.isUnique)
-    column = column + `.unique()`;
+  if (field.isRequired) column = column + `.notNull()`;
+  if (field.isId) column = column + `.primaryKey()`;
+  if (field.isUnique) column = column + `.unique()`;
   if (field.default) {
     const defVal = field.default;
     switch (typeof defVal) {
@@ -688,7 +795,7 @@ var addColumnModifiers3 = (field, column) => {
           drizzleImports3.add("sql");
           break;
         }
-        if (/^uuid\([0-9]*\)$/.test(value.name)) {
+        if (/^uuid\([0-9]*\)$/.test(value.name) || value.name === "uuid") {
           column = column + `.default(sql\`uuid()\`)`;
           drizzleImports3.add("sql");
           break;
@@ -706,8 +813,7 @@ var prismaToDrizzleColumn3 = (field) => {
   const colDbName = s(field.dbName ?? field.name);
   let column = `	${field.name}: `;
   const drizzleType = prismaToDrizzleType3(field.type, colDbName);
-  if (!drizzleType)
-    return void 0;
+  if (!drizzleType) return void 0;
   column = column + drizzleType;
   column = addColumnModifiers3(field, column);
   return column;
@@ -719,6 +825,7 @@ var generateSQLiteSchema = (options) => {
   const modelsWithImplicit = [...clonedModels, ...manyToManyModels];
   const tables = [];
   const rqb = [];
+  const rqbv2 = [];
   for (const schemaTable of modelsWithImplicit) {
     const tableDbName = s(schemaTable.dbName ?? schemaTable.name);
     const columnFields = Object.fromEntries(
@@ -726,9 +833,8 @@ var generateSQLiteSchema = (options) => {
     );
     const indexes = [];
     const relFields = schemaTable.fields.filter((field) => field.relationToFields && field.relationFromFields);
-    const relations = relFields.map((field) => {
-      if (!field?.relationFromFields?.length)
-        return void 0;
+    const relations2 = relFields.map((field) => {
+      if (!field?.relationFromFields?.length) return void 0;
       const fkeyName = s(`${schemaTable.dbName ?? schemaTable.name}_${field.dbName ?? field.name}_fkey`);
       let deleteAction;
       switch (field.relationOnDelete) {
@@ -760,7 +866,7 @@ var generateSQLiteSchema = (options) => {
 		.onDelete('${deleteAction}')` : ""}
 		.onUpdate('cascade')`;
     }).filter((e) => e !== void 0);
-    indexes.push(...relations);
+    indexes.push(...relations2);
     if (schemaTable.uniqueIndexes.length) {
       sqliteImports.add("uniqueIndex");
       const uniques = schemaTable.uniqueIndexes.map((idx) => {
@@ -786,9 +892,8 @@ ${Object.values(columnFields).join(",\n")}
 ${indexes.join(",\n")}
 })` : ""});`;
     tables.push(table);
-    if (!relFields.length)
-      continue;
-    drizzleImports3.add("relations");
+    if (!relFields.length) continue;
+    if (options.generator.config["relationsVersion"] == "v1") drizzleImports3.add("relations");
     const relationArgs = /* @__PURE__ */ new Set();
     const rqbFields = relFields.map((field) => {
       relationArgs.add(field.relationFromFields?.length ? "one" : "many");
@@ -805,6 +910,20 @@ ${indexes.join(",\n")}
     const rqbRelation = `export const ${schemaTable.name}Relations = relations(${schemaTable.name}, ({ ${argString} }) => ({
 ${rqbFields}
 }));`;
+    const rqbv2Fields = relFields.map((field) => {
+      const relName = s(field.relationName ?? "");
+      return `		${field.name}: ${field.relationFromFields?.length ? `r.one.${field.type}({
+			from: r.${schemaTable.name}.${field.relationFromFields.at(0)},
+			to: r.${field.type}.${field.relationToFields?.at(0)},
+			alias: '${relName}'
+		})` : `r.many.${field.type}({
+			alias: '${relName}'
+		})`}`;
+    }).join(",\n");
+    const rqbv2Relation = `	${schemaTable.name}: {
+${rqbv2Fields}
+	}`;
+    rqbv2.push(rqbv2Relation);
     rqb.push(rqbRelation);
   }
   const drizzleImportsArr = Array.from(drizzleImports3.values()).sort((a, b) => a.localeCompare(b));
@@ -812,20 +931,29 @@ ${rqbFields}
   const sqliteImportsArr = Array.from(sqliteImports.values()).sort((a, b) => a.localeCompare(b));
   const sqliteImportsStr = sqliteImportsArr.length ? `import { ${sqliteImportsArr.join(", ")} } from 'drizzle-orm/sqlite-core'` : void 0;
   let importsStr = [drizzleImportsStr, sqliteImportsStr].filter((e) => e !== void 0).join("\n");
-  if (!importsStr.length)
-    importsStr = void 0;
-  const output = [importsStr, ...tables, ...rqb].filter((e) => e !== void 0).join("\n\n");
-  return output;
+  if (!importsStr.length) importsStr = void 0;
+  const schemaFileName = options.schemaPath ? import_path3.default.basename(options.schemaPath, import_path3.default.extname(options.schemaPath)) : "schema";
+  let rqbv2Imports = [
+    `import { defineRelations } from "drizzle-orm";`,
+    `import * as schema from "./${schemaFileName}";`
+  ];
+  const rqbv2Relations = `
+export const relations = defineRelations(schema, (r) => ({
+${rqbv2.join(",\n")}
+}));`;
+  const relations = [...rqbv2Imports, rqbv2Relations].join("\n");
+  const schema = [importsStr, ...tables, ...options.generator.config["relationsVersion"] == "v1" ? rqb : []].filter((e) => e !== void 0).join("\n\n");
+  return [schema, relations];
 };
 
 // src/util/recursive-write/index.ts
 var import_fs = __toESM(require("fs"));
-var import_path = __toESM(require("path"));
-var recursiveWrite = async (path2, content) => {
-  import_fs.default.mkdirSync(import_path.default.dirname(path2), {
+var import_path4 = __toESM(require("path"));
+var recursiveWrite = async (path5, content) => {
+  import_fs.default.mkdirSync(import_path4.default.dirname(path5), {
     recursive: true
   });
-  import_fs.default.writeFileSync(path2, content);
+  import_fs.default.writeFileSync(path5, content);
 };
 
 // src/index.ts
@@ -839,19 +967,20 @@ var generator = (0, import_generator_helper4.generatorHandler)({
   },
   onGenerate: async (options) => {
     const dbType = options.datasources[0]?.provider;
-    let output;
+    let schema;
+    let relations;
     switch (dbType) {
       case "postgres":
       case "postgresql": {
-        output = generatePgSchema(options);
+        [schema, relations] = generatePgSchema(options);
         break;
       }
       case "mysql": {
-        output = generateMySqlSchema(options);
+        [schema, relations] = generateMySqlSchema(options);
         break;
       }
       case "sqlite": {
-        output = generateSQLiteSchema(options);
+        [schema, relations] = generateSQLiteSchema(options);
         break;
       }
       case void 0:
@@ -862,14 +991,18 @@ var generator = (0, import_generator_helper4.generatorHandler)({
 Supported database types: PostgreSQL, MySQL, SQLite.`
         );
     }
-    const folderPath = import_path2.default.resolve(
+    const folderPath = import_path5.default.resolve(
       options.generator.output?.value ?? (!!options.generator.output?.fromEnvVar ? process.env[options.generator.output.fromEnvVar] ?? defaultPath : defaultPath)
     );
-    const schemaPath = folderPath.endsWith(".ts") ? folderPath : import_path2.default.join(folderPath, "/schema.ts");
-    recursiveWrite(schemaPath, output);
+    const schemaPath = folderPath.endsWith(".ts") ? folderPath : import_path5.default.join(folderPath, "/schema.ts");
+    recursiveWrite(schemaPath, schema);
+    if (options.generator.config["relationsVersion"] !== "v1") {
+      const relationsPath = folderPath.endsWith(".ts") ? folderPath : import_path5.default.join(folderPath, "/relations.ts");
+      recursiveWrite(relationsPath, relations);
+    }
   }
 });
-var src_default = generator;
+var index_default = generator;
 // Annotate the CommonJS export names for ESM import in node:
 0 && (module.exports = {
   generator
